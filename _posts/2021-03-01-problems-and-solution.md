# problems and solutions

## 异常处理不当（偷偷吃掉/捕获粒度大/异常和返回混淆等）
解决方案：
1. 细粒度捕获控制异常
2. 下层服务不偷吃异常，一般由最上层决定是否忽略
3. 异常打印error日志

## 进程和线程并发安全考虑较少
解决方案：
对于分布式场景下多进程并发安全问题，一般采用两种解决方案，第一种采用分布式锁（Redis, Zookeeper, MySQL)实现多进程同步，第二种采用session保持策略将相同维度请求路由至同一线程，从而将进程并发问题降为线程并发同步问题。
线程安全问题，CAS，ThreadLocal等思想解决

## 配置变更MySQL+Redis一致性问题导致客户取不到最新配置
解决方案：
大致思路采用推拉结合策略，客户端与Redis版本超时未变时，直接查询MySQL获取最新数据，详细方案见：“管理态配置类数据（系统/业务/租户）变更同步客户端方案。

## 硬编码
解决方案：
1. Python使用的字典类型建议采用Class方式实现类似Java枚举值效果
2. 请求入参出参抽象为bean对象
3. 字符串&状态码抽取成有自带含义的常量，实现常量/变量自我解释。

## 异步服务调用册未实现请求和check分离，导致请求处理线程长期轮询check等待结果或超时，严重影响并发能力
解决方案：
请求处理与check线程分离，HTTP采用异步回调方式。详细方案见“HTTP异步服务调用方案”

## 请求&结果及使用MySQL或MongoDB存储，check获取结果性能较差
解决方案：
采用Redis+MySQL或Redis+MongoDB双写，check结果优先缓存获取，Redis故障降级MySQL或MongoDB详细方案见“运行态请求&结果&状态数据查询方案”

## 故障降级类
强依赖某一种存储（Redis/MySQL/MongoDB),存储集群故障服务将不可用
解决方案：
采用Redis+MySQL或Redis+MongoDB双写，check结果优先缓存获取，Redis故障降级MySQL或MongoDB详细方案见“运行态请求&结果&状态数据查询方案”
